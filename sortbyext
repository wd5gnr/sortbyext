#!/bin/bash
# Al Williams al.williams@awce.com

# sortbyext is a bash script to sort a busy directory by file/type extension
# It is made to be called by
# incron -- or you can manually pass file name to it
#
# Copyright (C) 2014 Al Williams (al.williams@awce.com)
#
# This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
# You should have received a copy of the GNU General Public License along with this program. If not, see http://www.gnu.org/licenses/.


# Just for fun, handle long options
args=( "$@" )
I=0
while [ ! -z "${args[$I]}" ]
  do
    parm="${args[$I]}"
    case "$parm" in
--config-file)
   args[$I]=-c
;;

--directory)
   args[$I]=-d
;;

--maximum-extension)
   args[$I]=-m
;;

--no-overwrite)
   args[$I]=-n
;;

--quiet)
   args[$I]=-q
;;

--)
   break  # stop doing options
;;
--?*)
   args[$I]=-h
;;
    esac
  I=$(( $I + 1 ))
  done
set -- "${args[@]}"


# process options
min=1
quiet=0
mvopt=
CFG=
OPTERR=0
function v { 
true
}
while getopts c:d:mnqvV:h arg
do
    case $arg in
	
      c)
	    CFG="$OPTARG"
;;
      d)
	    fdir="$OPTARG"
;;
      m)
         min=0
;;
      n)
	 mvopt=-n
;;
      q)
	 quiet=1
;;
      v)
         function v { 
	     echo $@ 
	 }
;;
      V)
	 VOUT="$OPTARG"   # not sure if function reinterprets
	 date >"$VOUT" 
	 function v {
	     echo $@ >>"$VOUT"
	 }
;;
	   
      h|\?|:)
	  >&2  cat <<EOF
sortbyext is a bash script to sort a busy directory by file/type extension
It is made to be called by
incron -- or you can manually pass file name to it

Copyright (C) 2014 Al Williams (al.williams@awce.com)

This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with this program. If not, see http://www.gnu.org/licenses/.

sortbyext by Al Williams (al.williams@awce.com)
Usage:
sortbyext [-d target_directory] [-c config_file] [-m] [-q] [-n] file [file...]
Files with extensions cause a directory to be made
corresponding to the extension and the file moved
there.

-c (--config-file) Sets a configuration file to use; if specified, it must exist or it is an error

-d (--directory) Sets the target directory

-h (--help) Shows this message (or any bad option)
-m (--maximum-extension) Causes the largest extension to be used
(e.g., x.tar.gz is a tar.gz file not a gz file)

-n (--no-overwrite) Prevents overwriting an existing file

-v Verbose mode (for debugging)

-q (--quiet) Inhibits output messages


Exclusions, Aliases and Mime Types
The program looks for a file in your home directory:
~/.config/sortbyext.conf
If this is not found, it then looks for
/usr/local/share/sortbyext/sortbyext.conf
If this is not found, it then looks for
/usr/share/sortbyext/sortbyext.conf

If one is found, the following processing occurs on a file
named foo.bar with mime type application/example
1) If the configuration file contains the line -bar, the script skips this file
2) If the configuration file contains the line -application/example, the script skips this file
3) If the configuration file contains the a matching line it will use 
the specified alias name as the directory name. Matching lines for this example
would include:
=test:bar
=test:application/example
=test:application/ 

All of these lines would match the file and cause it to be sorted into
directory test 
4) If there is no match on #3, and the file has a usable extenstion
The program uses the extension name (e.g., pdf) as the sort directory
5) If there is a sort directory set in step 3 or 4, the file is moved into it

You can copy /usr/local/share/sortbyext/sortbyext.conf to your ~/.config directory to customize. Comments in the file will further explain the format.

EOF
    exit 1
;;
    esac
done

v Command line: $@

shift $(($OPTIND-1))

v Processing: $@

# find config file
if [ ! -z "$CFG" ]
then
    if [ ! -f "$CFG" ]   # if User supplied, it must exist
    then
	>&2 echo Configuration file "$CFG" not found.
	exit 5
    fi
else
    CFG="~/.config/sortbyext.conf"   
fi    
if [ ! -f "$CFG" ]   # use user's file if present or use system file
then
    CFG="/usr/local/share/sortbyext/sortbyext.conf"
fi
if [ ! -f "$CFG" ]
then
   CFG="/usr/share/sortbyext/sortbyext.conf"
   if [ ! -f "$CFG" ]
   then
       CFG=
   fi
fi
v Config file $CFG


if [ -z "$fdir" ]
then
  fdir=$PWD
fi

while [ ! -z "$1" ]
do
    full="$1"
    shift	
v Processing $full
    if [ ! -f "$full" ]
    then 
	>&2 echo Can\'t find $full
	continue
    fi

    filename=$(basename "$full")
    if [ "$min" = 1 ] 
	then
	ext="${filename##*.}"
	else
	ext="${filename#*.}"
    fi
    filename="${full##*/}"



    if [ "$filename" == "$ext" ]
    then
	ext=""
    fi

    v filename is $filename
    v extension is $ext

    mime=$( file -b --mime "$full" )
    mime="${mime%;*}"
    
    v mime type is $mime

# the logic is, we use the mime type
# if and only if it has a substitute
# in the cfg file (an = sign)
# or if it is blocked in the cfg 
# file (-).
# So you can block by mime type
# of extension and if there is
# no matching mime type
# we use the extensions

mimeflag=0

if [ ! -z "$CFG" -a ! -z "$mime" ]
then
    if egrep -q -i -e "^-$mime\$" $CFG
     then
	v Ignoring based on mime type
	continue   # ignore!
    fi
    gline=$( egrep -i -m 1 -e "^=.*:$mime(:|[ \\t]*\$)" $CFG )
    if [ ! -z "$gline" ]
    then
	ext=${gline%%:*}
	ext=${ext#=}
	v Found mime match $ext
	mimeflag=1
    else
# check for partial mime match
       gline=$( egrep -i -m 1 -e "^=.*:${mime%/*}/(:|[ \\t]*\$)" $CFG )
       if [ ! -z "$gline" ]
       then
	ext=${gline%%:*}
	ext=${ext#=}
	v Found partial mime match $ext
	mimeflag=1
       fi
    fi

fi


# if no type, we are done
    if [ -z "$ext" ] 
    then
	v No type, skipping
	continue
    fi


    # convert ext to lowercase
    ext=$(echo $ext | tr '[:upper:]' '[:lower:]')

# Check exclusions
    reext=$( echo $ext | sed s/\\./\\\\./g )


    if [ ! -z "$CFG" -a $mimeflag = 0 ]
    then
	if  egrep -q -i -e "^-$reext[ \\t]*\$" $CFG 
	then
	    v Ignoring based on extension
	    continue  # ignore!
	fi
    # now check for alias
	gline=$( egrep -i -m 1 -e "^=.*:$reext(:|[ \\t]*\$)" $CFG )
	if [ ! -z "$gline" ]
	    then
	    ext=${gline%%:*}
	    ext=${ext#=}
	    v Found alias $ext from extension
	    fi
    fi


    dirname="$fdir/$ext"   
    v Set dirname $dirname


    # do it (create directory if needed and move)
    if [ -f "$dirname" ]
    then
	# refuse to make a directory "over" a file
	# because that will fail and the mv will then clobber
	>&2 echo Error: $dirname exists and is a file
	continue
    fi
    # make dir if necessary
    [ -d "$dirname" ] || mkdir "$dirname"
    # do the move (will clobber existing file!)
    if [ "$quiet" = 0 ]
    then
      echo Moving $full to $dirname
    fi
    v Moving $full to $dirname
    mv $mvopt "$full" "$dirname"
done
exit 0





